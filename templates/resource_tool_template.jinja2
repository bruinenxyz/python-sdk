import json
from langchain.base_language import BaseLanguageModel
from langchain.callbacks.manager import AsyncCallbackManagerForToolRun, CallbackManagerForToolRun
from langchain.output_parsers import PydanticOutputParser
from langchain.prompts.prompt import PromptTemplate
from langchain.tools import BaseTool
from pydantic import BaseModel, Field
from typing import Optional, List

from ..bruinen_api_client import AuthenticatedClient
from ..bruinen_api_client.api.accounts import find_all_accounts_for_user
from ..bruinen_api_client.models import ReturnedAccountDto
from ..bruinen_api_client.types import Response

# TODO import Bruinen SDK libraries, other requirements

class {{ schema_name }}(BaseModel):
    {% for parameter in parameters %}{{ parameter.name }}: {{ parameter.type }} = Field(description='{{ parameter.description }}')
    {% endfor %}{% if not has_parameters %}pass{% endif %}

class {{ class_name }}(BaseTool):
    name = '{{ tool_name }}'
    description = '''{{ tool_description }}
    {% if has_parameters %}
    Input should be a string query with the requested parameters as key/value pairs, separated by commas.
    Possible keys for the query are:
    
    {% for parameter in parameters %}"{{ parameter.name }}": "{{ parameter.type }}"
    {% endfor %}{% else %}
    Input should be an empty string.
    {% endif %}
    Output will be the text response from the {{ source_name_capitalized }} API.
    '''
 
    {% if has_parameters %}llm: BaseLanguageModel
    {% endif %}client: AuthenticatedClient
    user_id: str

    def _run(
        self,
        query: str,
        run_manager: Optional[CallbackManagerForToolRun] = None
    ) -> str:
        '''Run the tool.'''
        
        {% if has_parameters %}parser = PydanticOutputParser(pydantic_object={{ schema_name }})
        
        prompt = PromptTemplate(
            template="Parse the provided input string.\n{format_instructions}\n{query}",
            input_variables=["query"],
            partial_variables={"format_instructions": parser.get_format_instructions()}
        )
        _input = prompt.format_prompt(query=query)
        output = self.llm(_input.to_string())
        fields = parser.parse(output)
        
        {% endif %}response: Response[List["ReturnedAccountDto"]] = find_all_accounts_for_user.sync_detailed(client=self.client, user_id=self.user_id)
        accounts = json.loads(response.content)

        account_id = ''
        for account in accounts:
            if account['source'] == '{{ source_name }}':
                account_id = account['id']
        if account_id == '':
            return 'The user has not connected their {{ source_name.title() }} account; you should try authenticating {{ source_name.title() }} first.'
        else:
            # TODO implement this once the python SDK has sources included
            # If the user is authenticated, then we can use the account ID to make the request
            # res_repos = requests.get(f'https://api.bruinen.co/sources/github/repos?accountId={account_id}', headers=headers)
            # repos = res_repos.json()

            return ''

